# -*- coding: utf-8 -*-
"""2020-10-25_Anish_Lesson19

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FLNZB39pJjcIUpTH7087UwI4BuXWRxgG

# Lesson 19: Hunting Exoplanets In Space - Fast Fourier Transformation

### Teacher-Student Activities

In the previous class, we learnt data normalisation, why to normalise data and how to normalise data. Also, we normalised both the `exo_train_df` and `exo_test_df` DataFrames using the mean normalisation method.

In this class, we will learn how to apply Fast Fourier Transformation.

Let's run all the codes in the code cells that we have already covered in the previous classes and begin this class from the **Activity 1: Fast Fourier Transformation** section. You too run the code cells until the first activity.

---

#### Loading The Datasets

Create a Pandas DataFrame every time you start the Jupyter notebook.

Dataset links (don't click on them):

1. Train dataset 

   https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/whitehat-ds-datasets/kepler-exoplanets-dataset/exoTrain.csv

2. Test dataset 

   https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/whitehat-ds-datasets/kepler-exoplanets-dataset/exoTest.csv
"""

# Load both the training and test datasets.
import numpy as np
import pandas as pd

exo_train_df = pd.read_csv('https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/whitehat-ds-datasets/kepler-exoplanets-dataset/exoTrain.csv')
exo_test_df = pd.read_csv('https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/whitehat-ds-datasets/kepler-exoplanets-dataset/exoTest.csv')

# The shapes of the 'exo_train_df' and 'exo_test_df' DataFrames.
print(exo_train_df.shape)
exo_test_df.shape

"""In the previous classes, we have already checked the datasets don't have a missing value. So, we can skip that part.

---

#### Data Normalisation

Normalise data using the mean normalisation method.
"""

# Function for mean normalisation.
def mean_normalise(series):
  norm_series = (series - series.mean()) / (series.max() - series.min())
  return norm_series

# Applying the 'mean_normalise()' function horizontally on the training DataFrame.
norm_train_df = exo_train_df.iloc[:, 1:].apply(mean_normalise, axis=1)
norm_train_df.head()

# Inserting the 'LABEL' column to the 'norm_train_df' DataFrame.
norm_train_df.insert(loc=0, column='LABEL', value=exo_train_df['LABEL'])
norm_train_df.head()

# Applying the 'mean_normalise()' function on the testing DataFrame. 
norm_test_df = exo_test_df.iloc[:, 1:].apply(mean_normalise, axis=1)
norm_test_df.head()

# Inserting the 'LABEL' column to the 'norm_test_df' DataFrame.
norm_test_df.insert(loc=0, column='LABEL', value=exo_test_df['LABEL'])
norm_test_df.head()

"""---

#### Transpose Of A DataFrame
"""

# Transpose the 'exo_train_df' using the 'T' keyword.
exo_train_df.T

"""---

#### Activity 1: Fast Fourier Transformation^^^

As discussed in the next class, as a next step, we need to apply the Fourier Transformation on our dataset.

**What is Fourier Transformation?**

To understand the Fourier Transformation concept, let's go back to the line plots that we created in the previous classes. Recall the line plot for the `star_0` Pandas series. The graph has a wave-like pattern with periodic downward peaks. As the value on the $x-axis$ increases, the `FLUX` values on the $y-axis$ periodically increase and decrease.
"""

# Student Action: Create a line plot for the first star in the 'norm_train_df' DataFrame.
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

star0 = norm_train_df.iloc[0,1:]
print(star0)
plt.figure(figsize=(20, 10))

plt.plot(np.arange(1, 3198), star0)
plt.grid()
plt.show()

"""So there is a clear fluctuation in the `FLUX` values which drops, 

- whenever a planet comes between its star and the Kepler telescope while orbiting the star and

- whenever the planet goes behind the star (as observed by Kepler telescope) while orbiting the star

To visualise the phenomenon described above, watch a video by clicking on the link provided in the **Activities** section under the title **Transiting Exoplanet Light Curve**.

These fluctuations occur after every fixed interval as you might have noticed. When the planet completes one revolution around the star, one cycle completes. This cycle repeats after a fixed time interval. E.g., Earth completes one revolution around the Sun in approximately 365.25 days so Earth's one cycle is 365.25 days long which repeats again and again. 

The length of one cycle (in the unit of time) is called frequency. It is calculated as

$$f = \frac{1}{T}$$

where 
$T$ 
is time in seconds. The SI unit of frequency is **Hertz** denoted as **Hz**.

So, the Earth's frequency is the reciprocal of 
$365.25$
days, i.e., 

$$f_{\text{Earth}} = \frac{1}{365.25} $$

$$f_{\text{Earth}}= \frac{1}{365.25 \times 24 \times 60 \times 60} \space \text{Hz}$$ 

$[ \because 1 \space \text{day}  = 24 \times 60 \times 60 = 86400 \space \text{seconds} ]$

In a nutshell, we can compute the time-period of revolution (or cycle or frequency) of a planet around its star using the periodic variation in the flux values. The length of the period (or the length of one cycle) is the frequency of revolution of a planet around its star.

**Why do we need to apply Fourier Transformation?**

The Fourier transformation converts time-dependent data into frequency-dependent data.

<img src='https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/images/lesson-17/fft_example.png' width=600>

*Image credits: https://www.mathworks.com/help/fixedpoint/examples/convert-fast-fourier-transform-fft-to-fixed-point.html*

As you can see in the images above, first, we have a time-dependent data that is later converted into a frequency-dependent data. In the *Magnitude vs Frequency* graph, you can notice the peaks are located at the 
$f = 0.2, 0.5, 3.55$ 
and 
$3.8$ 
points on the frequency axis.

Similarly, we can get the frequencies of the planets revolving around its star. Our predict model (Random Forest Classifier) can capture these frequencies while learning from the training data. Thus, allowing the prediction model to make accurate predictions. 

Let's go through one simple example of a very clear periodic variation.

Refer to the code below. Ignore the code for the time being. Just observe the line graph that plots 
$y$ 
vs 
$x$.
"""

# Teacher Action: Run this code to make a line plot between the 'x' and 'y' values.
import numpy as np
import matplotlib.pyplot as plt

N = 600 # Number of sample points
T = 1.0 / 800.0 # sample spacing

t = np.linspace(0.0, N*T, N)
y = np.sin(50.0 * 2.0 * np.pi * t) + 0.5 * np.sin(75.0 * 2.0 * np.pi * t)

plt.figure(figsize=(20, 5))
plt.plot(t, y)
plt.grid()
plt.show()

"""As you can see, the graph has a clear periodic variation. So, it must also have a frequency.

**The theory below is meant ONLY for the**
$12^{\text{th}}$ 
**and above standard student w.r.t. the NCERT Physics syllabus**

The above graph represents the sinusoidal wave having the equation
$$y = \sin((50 \times 2 \pi)t) + 0.5 \sin((75 \times 2 \pi)t)$$

where 
$t$
is time.

So, the above sinusoidal wave is a linear combination of two sinusoidal waves having the equations

$$ y_1 = \sin((50 \times 2 \pi)t) \space \text{and} \\
y_2 = 0.5 \sin((75 \times 2\pi)t)
$$

A general equation of sinusoidal wave is given by
$$y = A \sin((2\pi f)t + \phi)$$

where 
$A$
is amplitude,
$f$
is frequency and
$\phi$
is phase difference.

So, on comparing the two sinusoidal waves,
$y_1 \text{and} y_2$
with the general equation of a sinusoidal wave, we get

$$f_{1} = 50 \space \text{Hz} \space \text{and} \\ 
f_2= 75 \space \text{Hz}$$

Hence, the resulting sinusoidal wave has a combined frequency of 50 Hz and 75 Hz which should reflect in the frequency-dependent graph.

The code below applies Fourier transformation on the values stored in the `y` variable using the `fft.fft()` function which exists in the NumPy module. The transformed values are stored in the `yf` variable.
"""

# Teacher Action: Run this code to make a line plot between the 'xf' and 'yf' values.
yf = np.fft.fft(y)
tf = np.linspace(0.0, 1.0/(2.0*T), N//2)

plt.figure(figsize=(20, 5))
plt.plot(tf, 2.0/N * np.abs(yf[0:N//2]))
plt.grid() 
plt.show()

"""As you can see, there are two peaks at the numbers `50` and `75` on the 
$x-axis.$
These two values are frequencies. This means the object whose periodic motion described by the equation `y = np.sin(50.0 * 2.0 * np.pi * t) + 0.5 * np.sin(75.0 * 2.0 * np.pi * x)` oscillates with a combined frequency of `50` Hz and `75`Hz.

---

#### Activity 2: The `np.fft.fft()` & `np.abs()` Functions

Let's apply Fourier transformation on the first star, i.e., `star_0` using the `np.fft.fft()` function and then make its line plot. 

**Note:** The acronym `fft` in the `fft.fft()` function stands for Fast Fourier Transformation. It's just the name of the algorithm which applies Fourier transformation (a mathematical concept).
"""

# Teacher Action: Apply the 'fft.fft()' function on the 'star_0' Pandas series.
fft_star_0= np.abs(np.fft.fft(star0))
fft_star_0

"""The `fft.fft()` function returns an array of the transformed values. Note that we have applied another function too. It's `abs()` to get the absolute values of the values stored in the array.

**The Absolute Value**

The absolute values are usually calculated when the transformed values (after applying Fourier transformation) turn out to be complex numbers. A complex number is a combination of a real number and an imaginary number. E.g., 
$2 + 3j \left( \text{where} \space j = \sqrt{-1} \right)$
is a complex number because 
$2$ 
is a real number and 
$3j$ 
is an imaginary number. A multiple of 
$\sqrt{-1}$ 
is an imaginary number. 

The absolute value of the complex number 
$(2 + 3j)$ is $\sqrt{2^2 + 3^2} = \sqrt{13} = 3.605$
"""

# Student Action: Calculate the absolute value of the complex number, z = 2 + 3j.
np.abs(2+3j)

"""For a general complex number,
$$z = a+bj$$
the absolute value is calculated as
$$|z| = \sqrt{a^2 + b^2}$$

where 
$a, b$
are some real numbers and
$j = \sqrt{-1}$

The 
$\sqrt{-1}$
is called **iota** and is often represented as 
$i = \sqrt{-1}$
in many Math textbooks.

A complex number cannot be plotted on a real number line because it contains an imaginary part. Contrary to its name, a complex number reduces the complexity of calculations, especially in the problems related to geometry.  


Now, let's find out the frequencies for the `star_0` Pandas series.
"""

# Student Action: Apply the 'fft.fftfreq()' function on 'len(star_0)' to get the frequencies of the 'star_0' Pandas series.
freq = np.fft.fftfreq(len(star0))
freq

"""Note that the frequency array will be the same for all the stars because it depends on the length of the array/series. All the stars have the same array/series length.

Now, let's plot the Fourier transformed values with the frequency values for the `star_0` Pandas series.
"""

# Student Action: Create a line plot between the 'fft_star_0' and 'freq' values.
plt.figure(figsize = (20, 10))

plt.plot(freq, fft_star_0)
plt.grid()
plt.show()

"""The 5 tall peaks in the above graph:

1. At `-0.08` (approx)

2. At `-0.03` (approx)

3. At `-0.00`

4. At `0.03` (approx)

4. At `0.08` (approx)

Notice that the above plot is symmetric. So, either we can consider the left-half of the graph or the right-half. They both mean the same thing. Also, there is a huge spike close to `0`. It denotes that `star_0` has a frequency very close to `0`. If we plot the above graph for the first 10 values only, then we will be able to observe the peak very closely.
"""

# Student Action: Plot a line plot between the 'fft_star_0' and 'freq' values for the first 10 values only.
plt.figure(figsize=(20, 10))

plt.plot(freq[ :10], fft_star_0[ :10])
plt.grid()
plt.show()

"""As you can see, the peak lies at some point between `0.001` and `0.0015`, i.e. at `0.00125`.

Now, let's apply the Fourier Transformation on the entire `exo_train_df` dataset. For this purpose, we will have to create a function to apply the `fft.fft()` function on an entire DataFrame using the `apply()` function.

Let's name it `fast_fourier_transform()`. It should do two actions:

1. Transform a Pandas series using the `fft.fft()` function.

2. Calculate the absolute value of each item in the series.
"""

# Student Action: Create a function and name it 'fast_fourier_transformation()' to apply Fast Fourier Transformation on the DataFrames.
def fast_fourier_transformation(star):
  fft_star = np.fft.fft(star, n=len(star))
  return np.abs(fft_star)

"""This time we will apply the `fast_fourier_transform()` function vertically. So, before applying the function, we will take the transpose of the original DataFrame. Then, we will apply the `fast_fourier_transform()` function vertically. Then, we will again take the transpose of the DataFrame.

**Note:** We don't want to transform the `LABEL` values. We want to transform the `FLUX` values only.
"""

# Teacher Action: Apply the 'fast_fourier_transform' function on the transposed 'norm_train_df' DataFrame.

# Here, we first take the transpose of the DataFrame and then apply the fast_fourier_transform vertically. So axis = 0 is specified here.
x_train_fft_T = norm_train_df.iloc[:,1:].T.apply(fast_fourier_transformation, axis=0)
# After transforming the 'FLUX' values, we again take the transpose.
x_train_fft= x_train_fft_T.T
# Print the first five rows of the transformed DataFrame.
x_train_fft.head()

"""---

#### Activity 3: The `xlabel()` & `ylabel()` Functions

Now, let's plot the line plots for the stars `34` to `40` to see observe the frequency variations. The stars in the rows `34` to `36` are the ones having a planet whereas the stars beyond the row `37` are the ones not having a planet.

Since we are going to plot 7 graphs in one go, let's label their $x-\text{axis}$ using the `xlabel()` function of the `matplotlib.pyplot` module. Similarly, you can also label the $y-\text{axis}$ using the `ylabel()` function of the `matplotlib.pyplot` module.

**Note**: The `xlabel()` and `ylabel()` functions accept only string values.
"""

# Teacher Action: Create line plots for the transformed Pandas series for the stars 34 to 41 in the 'x_fft_train' DataFrame.
for i in range(34,42):
  plt.figure(figsize=(15,7))
  plt.xlabel(str(i))
  plt.ylabel('FLUX')
  plt.plot(freq,x_train_fft.iloc[i,:])
  plt.grid()
  plt.show()

"""The prediction model later, when deployed, should look for the different frequency pattern for different stars. Based on these patterns, it should classify whether a star has a planet or not.

Now, you apply the `fast_fourier_transform()` function on the `norm_test_df` `FLUX` values only. Before and after applying this function, take the transpose of the DataFrame.
"""

# Student Action: Apply the 'fast_fourier_transform()' function on the transposed 'norm_test_df' DataFrame.
fft_x_test_T = norm_test_df.iloc[:,1:].T.apply(fast_fourier_transformation, axis=0)
fft_x_test = fft_x_test_T.T

fft_x_test.head()

"""Now, you create the line plots for the stars in the rows `3 to 7`  in the transformed test DataFrame. Also, label the $x-axis$ with the row number."""

# Student Action: Plot the line plots for the stars in the rows '3' to '7'  in the transformed test DataFrame.
for x in range(3, 7):
  plt.figure(figsize=(20, 10))
  plt.xlabel(str(x))
  plt.ylabel("FLUX")
  plt.plot(freq, fft_x_test.iloc[x,:])
  plt.show()

"""Now that we have applied Fourier transformation, our prediction model should be able to recognise the different frequency patterns for different stars and hopefully should be able to classify the stars correctly as required.

In the next class, we will how to manually synthesize data to have the equal number of class `1` and class `2` values in the `exo_train_df` DataFrame. Right now there are only 37 class `2` and 5050 class 1 values because of which the `exo_train_df` DataFrame is highly imbalanced.

---
"""