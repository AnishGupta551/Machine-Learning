# -*- coding: utf-8 -*-
"""Copy of 2020-11-11_Anish_Lesson25

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FzxZ8d2420-hBuepRKmCBkIr0GvIuq8u

# Lesson 25: Meteorite Landings - Cartograms

### Teacher-Student Activities

In the previous classes, we learnt how to remove the unwanted data points from a data set and how to treat the missing values. We also learnt how to create a simple map (or a cartogram) using the `folium` module. In this class, we will continue from where we left off two classes back, i.e., we will continue from the part where we learnt how to treat the missing values. There we replaced the missing year values with the median year value.

Now, we need to create cartograms for the meteorite landing sites. Essentially, we want to create a world map having markers for the location from where a meteorite was found. Since there are over 30,000 meteorites, plotting the markers for all of them in a single cartogram will become too cluttered to make any kind of interpretation. Hence, we will create cartograms for the 5 year period at a time. For e.g., we will create different cartograms for 2001 to 2005 period, 2006 to 2010 period, 2011 to 2015 period etc.

Let's quickly run the codes that we have already covered in the previous classes and begin this class from **Activity 1: Converting The `year` Values To `int`** section. You too run the codes until the first activity.

---

#### The Data

The dataset contains the following variables:

1. `name`: the name of the place where a meteorite was found or observed.

2. `id`: a unique identifier for a meteorite.

3. `nametype`: one of the following:
    
    - `valid`: a typical meteorite.
    
    - `relict`: a meteorite that has been highly degraded by the weather on Earth.

4. `recclass`: the class of the meteorite; one of a large number of classes based on physical, chemical, and other characteristics. 

5. `mass:` the mass of the meteorite, in grams

6. `fall`: whether the meteorite was seen falling, or was discovered after its impact; one of the following:

    - `Fell`: the meteorite's fall was observed.
    
    - `Found`: the meteorite's fall was not observed.

7. `year`: the year the meteorite fell, or the year it was found (depending on the value of fell).

8. `reclat`: the latitude of the meteorite's landing.

9. `reclong`: the longitude of the meteorite's landing.

10. `GeoLocation`: a parentheses-enclose, comma-separated tuple that combines `reclat` and `reclong` values.

---

#### Loading The Dataset

Dataset Link (don't click on them): 

https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/whitehat-ds-datasets/meteorite-landings/meteorite-landings.csv
"""

# Import the 'numpy', 'pandas' and 'matplotlib.pyplot' libraries for this class and create a DataFrame.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

met_df = pd.read_csv('https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/whitehat-ds-datasets/meteorite-landings/meteorite-landings.csv')
met_df.head()

# Number of rows and columns in the DataFrame. 
met_df.shape

"""---"""

# Descriptive statistics for the 'year' values in the 'met_df' DataFrame. 
met_df['year'].describe()

"""---

#### Slicing A Dataframe And The Ampersand (`&`) Logical Operator

**Syntax:** `data_frame[condition1 & condition2 & condition3 ... conditionN]`

where `N` is the total number of conditions to be applied.
"""

# Rows containing the year values less than 860 and greater than 2016.
correct_years_df = met_df[(met_df['year'] >= 860) & (met_df['year'] <= 2016)]
correct_years_df

"""---

#### Removing The Invalid `reclong` Values
"""

# Rows having the 'reclong' values greater than or equal to -180 degrees and less than or equal to 180 degrees.
correct_long_df = correct_years_df[(correct_years_df['reclong'] >= -180) & (correct_years_df['reclong'] <= 180)]
correct_long_df

"""---

#### Removing The Rows Containing `0 N, 0 E` Values
"""

# Rows containing the 0 'reclat' and 0 'reclong' values from the 'correct_long_df'.
correct_lat_long_df = correct_long_df[~((correct_long_df['reclat'] == 0) & (correct_long_df['reclong'] == 0))]
correct_lat_long_df

"""---

#### Check For The Missing Values
"""

# Check whether the 'correct_lat_long_df' DataFrame has missing values or not. 
correct_lat_long_df.isnull().sum()

# Rows containing the missing 'mass' values in the 'correct_lat_long_df' DataFrame.
correct_lat_long_df[correct_lat_long_df['mass'].isnull() == True]

# Descriptive statistics for the 'mass' column in the 'correct_lat_long_df' DataFrame.
correct_lat_long_df['mass'].describe()

"""The median `mass` value is 29.6 grams. After replacing the `NaN` values with the median value all the above rows in the `mass` column should have `29.6` value.

---

#### The `index` Keyword
"""

# List of the indices of above rows.
row_indices = correct_lat_long_df[correct_lat_long_df['mass'].isnull() == True].index
row_indices

"""So, here we have an array containing the indices of all the rows having the `NaN` mass values. There are 107 such rows.

---

#### The `loc[]` Function
"""

# Missing 'mass' values from 'correct_lat_long_df' DataFrame using the 'loc[]' function. 
missing_mass_values = correct_lat_long_df.loc[row_indices, 'mass']
missing_mass_values

"""Here, we have a Pandas series which contains all the `NaN` mass values. The length of this series is `107`.

---

#### Replacing The Missing `mass` Values

**Note:** The code below will throw a warning. Ignore it!
"""

# Missing values in the 'mass' column in the 'correct_lat_long_df' DataFrame with median of mass.
correct_lat_long_df.loc[row_indices, 'mass'] = correct_lat_long_df['mass'].median()

# Check whether all the missing mass values have been replaced by the median of the mass values or not.
correct_lat_long_df.loc[row_indices, :]

# Descriptive statistics for the 'mass' column in the above DataFrame containing 107 rows.
correct_lat_long_df.loc[row_indices, 'mass'].describe()

# Descriptive statistics for the 'mass' column in the 'correct_lat_long_df' DataFrame.
correct_lat_long_df['mass'].describe()

"""---

#### Activity 1: Converting The `year` Values To `int`

Now that we have replaced the missing `mass` values with the `median` value, let's convert the `year` values into integer type values because currently they are floating-point values. The `year` values as the floating-point type doesn't make sense because a year is always a whole number.

To convert values in a Pandas series to another data-type, we use the `astype()` function. It takes the target data-type as an input and returns the values in the series in the desired data type.

**Note:** The code below will throw a warning. Ignore it!
"""

# Student Action: Convert the 'year' values into integer type values.
correct_lat_long_df["year"] = correct_lat_long_df["year"].astype(int)
correct_lat_long_df

"""Now, let's confirm whether we have converted the `year` values into integer using the `dtype` keyword. We learnt about the `dtype` keyword in the NumPy arrays class."""

# Student Action: Confirm whether the 'year' values are integer or not using the 'dtype' keyword.
correct_lat_long_df["year"].dtype

"""---

#### Activity 2: The Good & Withered Meteorites Separation

Our next task is to make a cartogram for the landing locations of the meteorites found on Earth. They were found in two conditions: the good and the withered condition. The condition of the meteorites is described in the `nametype` column. If the `nametype` value is `Valid`, then it means the condition of the meteorite found is good whereas if the `nametype` value is `Relict`, then it means the condition of the meteorite found is withered.

Before creating a cartogram, let's create two DataFrames.

- The first DataFrame for the meteorites which were actually found and are in good condition (`nametype` value is `Valid`).

- The second DataFrame for the meteorites which were actually found and are in a withered condition (`nametype` value is `Relict`).
"""

# Student Action: Find out how many meteorites are in good condition ('nametype' == 'Valid') and how many are withered ('nametype' == 'Relict').
correct_lat_long_df["nametype"].value_counts()

"""So, there are only 69 meteorites which have withered due to the prolonged exposure to probably the extreme weather conditions. The other meteorites are in good condition. Since the withered meteorites are fewer in numbers, let's create a DataFrame for the same and create its cartogram because it would be easier for us to spot these meteorites on a map."""

# Student Action: Create a DataFrame called 'found_relict_df' and store data only for those meteorites which were actually found.
found_relict_df = correct_lat_long_df[(correct_lat_long_df["nametype"]=="Relict") & (correct_lat_long_df["fall"]=="Found")]
found_relict_df

"""Now, create a DataFrame for the meteorites which were actually found and are in good condition (`nametype` value is `Valid`)."""

# Student Action: Create a DataFrame called 'found_valid_df' and store data only for those meteorites which were actually found.
found_valid_df = correct_lat_long_df[(correct_lat_long_df["nametype"]=="Valid") & (correct_lat_long_df["fall"]=="Found")]
found_valid_df

"""So there are 30,871 meteorites which were found in good condition.

---

#### Activity 3: Cartogram For Withered Meteorites^

Let's create a cartogram for all the withered meteorites that were found. We need to add a marker for every single meteorite listed in the `found_relict_df`. Hence, we need to use the `for` loop to iterate through each entry in the `found_reliect_df` DataFrame. Then we also need to use the `loc[]` function to get the latitude and longitude values for each meteorite. Since we need to display the location of the meteorite site in each marker through the popup window, we again will have to use the `loc[]` function. 

**Note:** If you are creating a world map, then provide the coordinates of the equator (`0, 0`) as input in the `Map()` function to create a symmetric map.
"""

# Teacher Action: Create a cartogram for the landing sites of the meteorites found in the withered condition.
import folium
map1= folium.Map(location=[0,0], width='90%', height='90%', zoom_start=2)

for i in found_relict_df.index:
  folium.Marker(location= [found_relict_df.loc[i,'reclat'], found_relict_df.loc[i,'reclong']] , popup=found_relict_df.loc[i,'name']).add_to(map1)
map1

"""In the above code:

1. We created a world map by providing the coordinates of the equator as an input to the `Map()` function with the `zoom_start` value equal to 1. For a better visibility, we have chosen the `Stamen Toner` background for the map.

2. Next, we are adding the markers to the map for each meteorite existing in the `found_relict_df` DataFrame using the `for` loop.

    - The `for` loop iterates through each index in the `found_relict_df` DataFrame. Recall that to get the array containing the indices for a Pandas series, we use the `index` keyword.

    ```
    for i in found_relict_df.index:
    ```

    - Using the `loc[]` function, we get the `reclat`, `reclong` and `name` values from the `found_relict_df` DataFrame.

    ```
    for i in found_relict_df.index:
        folium.Marker(location=[found_relict_df.loc[i, 'reclat'], found_relict_df.loc[i, 'reclong']],
                popup=found_relict_df.loc[i, 'name']).add_to(map1)
    ```

    - The `add_to()` function adds a marker to the `map1` map for each meteorite existing in the `found_relict_df` DataFrame.

---

#### Activity 4: Cartograms For Good Condition Meteorites^^^

Now, let's make a cartogram for the meteorites which are found in good condition (`found_valid_df`). As we saw earlier, 30,871 meteorites were found in good condition. Hence, creating markers for each of these meteorites is impractical. So, we can slice the `found_valid_df` DataFrame based on year.

Let's estimate how many meteorites were found in good condition after the year 2010.
"""

# Student Action: Find out how many meteorites were found in good condition after the year 2010.
found_valid_df[found_valid_df["year"]>2010].shape

"""So, 398 meteorites were found in good condition after the year 2010. Let's create a cartogram for these meteorites. We will use the same process which we used to create a cartogram for the withered meteorites."""

# Student Action: Create a cartogram for the meteorites found in good condition after the year 2010. Popup the location name.
map2 = folium.Map(location=[0, 0], width="90%", height="90%", zoom_start=2)

for x in found_valid_df[found_valid_df["year"]>2010].index:
  folium.Marker(location=[found_valid_df.loc[x, "reclat"], found_valid_df.loc[x, "reclong"]], popup=found_valid_df.loc[x, "name"]).add_to(map2)

map2

"""Similarly, let's create a cartogram for the meteorites found in good condition from 2008 to 2010 (both inclusive)."""

# Student Action: Find out how many meteorites found in good condition from 2008 to 2010 (both inclusive).
found_valid_df[(found_valid_df["year"]>=2008) & (found_valid_df["year"]<=2010)].shape

"""So, 976 meteorites were found in good condition from 2008 to 2010 (both inclusive). Now, let's create a cartogram for these meteorites."""

# Student Action: Create a cartogram for the meteorites found in good condition from 2008 to 2010 (both inclusive).
map3 = folium.Map(location=[0, 0], width="90%", height="90%", zoom_start=2, tiles="Stamen Toner")

for x in found_valid_df[(found_valid_df["year"]>=2008) & (found_valid_df["year"]<=2010)].index:
  folium.Marker(location=[found_valid_df.loc[x, "reclat"], found_valid_df.loc[x, "reclong"]], popup=found_valid_df.loc[x, "name"]).add_to(map3)

map3

"""Similarly, let's create a cartogram for the meteorites found in good condition from 2005 to 2007 (both inclusive)."""

# Student Action: How many meteorites were found in good condition from 2005 to 2007 (both inclusive)?
found_valid_df[(found_valid_df["year"]>=2005) & (found_valid_df["year"]<=2007)].shape

"""So, 1688 meteorites were found in good condition from 2005 to 2007 (both inclusive). Now, let's create a cartogram for these meteorites."""

# Student Action: Create a cartogram for the meteorites found in good condition from 2005 to 2007 (both inclusive).
map4 = folium.Map(location=[0, 0], width="90%", height="90%", zoom_start=2, tiles="Stamen Toner")

for x in found_valid_df[(found_valid_df["year"]>=2005) & (found_valid_df["year"]<=2007)].index:
  folium.Marker(location=[found_valid_df.loc[x, "reclat"], found_valid_df.loc[x, "reclong"]], popup=found_valid_df.loc[x, "name"]).add_to(map4)

map4

"""The `popup` parameter displays the name of the location on a popup box when clicked on a marker. Along with the city name, we can also display the mass of a meteorite in the popup of the markers. For this, we will have to use **string concatenation**. It is a process in which two or more Python objects can be joined together into one string object.

---

#### Activity 5: String Concatenation^^

Let's understand the string concatenation concept using a very simple example. Consider that we have two different information saved in the two different variables

1. `name = 'Bruce Wayne'`

2. `age = '30'`

Let's create the `'Hi! My name is Bruce Wayne and I am 30 years old.'` sentence using the two variables, then we can use string concatenation. To concatenate strings, you need to use the `+` operator.

**Note:** The code below will throw the `TypeError` error which is expected. So, don't worry about it.
"""

# Teacher Action: Create the 'Hi! My name is Bruce Wayne and I am 30 years old.' string using string concatenation method 
# without converting the 'age' into an integer.
name = 'Bruce Wayne'
age = 30

sentence= "My name is " + name +  "and I am " + age + "years old.."
sentence

"""The above code throws an error because we are trying to concatenate an integer data type with a string data type. If a variable contains a non-string data type then you first have to convert it into a string using the `str()` function and then use the `+` operator to concatenate the strings."""

# Teacher Action: Create the 'Hi! My name is Bruce Wayne and I am 30 years old.' string using string concatenation method 
# by converting the 'age' into an integer.
name = 'Bruce Wayne'
age = 30

sentence= "My name is " + name +  " and I am " + str(age) + " years old.."
sentence

"""Similarly, we can concatenate each `name` value with the corresponding `mass` value and then display both the city names and the mass of a meteorite through the `popup` parameter. Let's display the name and the mass of the meteorites for the meteorites found in a condition from the year 2005 to 2007 (both inclusive)."""

# Student Action: Use the string concatenation method to display the name of the place and mass of the meteorite in the marker popup.
map5 = folium.Map(location=[0, 0], width="90%", height="90%", zoom_start=2, tiles="Stamen Toner")

for x in found_valid_df[(found_valid_df["year"]>=2005) & (found_valid_df["year"]<=2007)].index:
  folium.Marker(location=[found_valid_df.loc[x, "reclat"], found_valid_df.loc[x, "reclong"]], popup=found_valid_df.loc[x, "name"] + " - " + str(found_valid_df.loc[x, "mass"]/1000)+" kg").add_to(map5)

map5

"""If you click on any of the markers, you will see that it displays both the city name and the mass of a meteorite. We can also add circular markers such that the radius of a circular marker represents the mass of the meteorite fallen. So, the bigger the circle, the heavier the meteorite."""

# Student Action: Add circular markers such that the radius of a circular marker represents the mass of the meteorite fallen.
map6 = folium.Map(location=[0, 0], width="90%", height="90%", zoom_start=2, tiles="Stamen Toner")

for x in found_valid_df[(found_valid_df["year"]>=2005) & (found_valid_df["year"]<=2007)].index:
  folium.Circle(location=[found_valid_df.loc[x, "reclat"], found_valid_df.loc[x, "reclong"]], 
                radius = found_valid_df.loc[x, "mass"], color = "gray", fill=True, fill_color = "gray",
                popup=found_valid_df.loc[x, "name"] + " - " + str(found_valid_df.loc[x, "mass"]/1000)+" g").add_to(map6)

map6

"""In your free time, you create cartograms for the remaining meteorites. In the next class, we will learn how to create the count plots.

**Note:** You can atttempt **Project 7** now.

---
"""